Steps to publishing
  - Library of common mix chunks (sanitizers, libc++, lines of code count)
  - CI w/ perf numbers up and running
  - Get `bit -m msan -m debug` passing
  - Running tests (And in verbose mode?)
  - error on json unknown
  - Make caching work!!!!
  - C++ Include detector plugin
  - Print what files needed / wanted unproduceable file

Pretty
  - Print command to build just what directly failed
  - Tools built bootstrapping
  - Distributed build / lambda
  - ccache. We know all the things being touched. Hash and store to a DFS.
    - Actually setup as idempotent build system. Basically we swap out subprocess runs with remote subprocess runs when it's
      profitable.
  - Shortcut critical chain / forward finding work rather than waiting (a.c -> a.o -> found all the deps, build everything -> a).
  - Some way of sharing code / downloading code / package managementy.
  - Replace TCodeLocation with std::source_location

Rewrite config system
  - use proper layers (project, user, system)
  - Allow mixins (-m debug,release,small-debug)
    - Adding/removing options in mixins, system config based on "one of x" system choice
  - Allow "One of X" user choices
    Ex: GCC, Clang, MSVC, ICC
  - Sane defaults for new code. (-Weverything, -std=c++1y)
{
  "dependencies": {
    "pkgpanda": {
      "method": "url_extract",
      "source": "gihtub.com/pkgpanda/pkgpanda",
      "build": {
        "type": "script"
        "source": "dep/build_pkgpanda"
      }
    }
  }
}


On startup find system include directories and turn them into "Trees"
`echo | g++ -x c++ -Wp,-v -E -`
Convert system include -> library using config

Loading new job kinds at runtime
  - Default load all, allow projects to specify exactly what to load
Bootstrap-generating tool
Tooling mixins (-t valgrind, -t callgrind, -t clang-analyze, -t asan, ...)
Dynamicaly loading / adding tooling options
  - Choose names to load
Native packaging creation?
make install equivalent
virtualenv building
Dependency downloading / building / installing
DistCC
Configuration layering
  - .user.bit, XDG_CONFIG_DIR / ~/.config
  - Packaging default options (Ala makepkg.conf)
Multiple subprojects in one repository
  - Subproject discovery? (Useful for closed vs. open)
System header -> library mapping for link deps.
Sublime editor integration
  - Autocomplete
  - Build systems tab
Command line autocompletion
"Run built program" utility / helper
  -- Also option to just say 'Build then do x'
New job queue which knows scheduling things optimistically
Make the JobRunner a proper thread pool


-----
To review:

Configure for bit (CXX, CC, CXXFLAGS, CCFLAGS, LD, LDFLAGS):
  - Ideally also allow adding platform/tool/etc. specific variables/flags to config.
  - Have a 'setup' step analogous to ./configure
  - Captures a static set of environment variables which are then used
    for the build.

Cross-project includes / dependencies
Download third party packages / repositories
  http://golang.org/cmd/go/#hdr-Remote_import_paths
  - Either #include <github.com/foo/bar>
  - Dependency file which maps repo to some include prefix.

Test / examples for several open source codebases?

Command line autocompletion

No folders outside of root folder mode

Checks:
  - Explicit approval if # tests is reduced
  - Test for operation on {osx, linux} x {clang, gcc}
  - clang-formatted all code

Simpler <base/split.h> (With a better name)?

Bootstrap script generator
  - Bootstrapping test?

A good Single Producer Multiple Consumer queue to

Unify on THROWER w/ reduced (Simplified) interface.

A great many config options should be optional to specify (cmd.ld.libs, cmd.ld.flags, etc)

Cleanup base/json API

Allow simple plugging of tools (Loadable modules + Text API)

Extend / clean test harness:
  - Isolators? (Network, etc)
  - Preconditions (needs 5 GB ram, 10 cores, root, sole of type, etc.)
  - Run fixtures in parallel?
  - The test output code is hard to follow, result pages not always the cleanest
  - XML output report for consumption via existing tools.

buildit -- wrapper for other build systems (Need to ingest autoconf / makefiles, CMake)


Random thoughts:
Need to be able to do "parameterized builds"
  - Ala flake8 or Travis CI
  - Have a collection of config files stating the build parameters
    Env stuff: (clang, gcc, versions, etc.)
    Project stuff: Config, mixins
  - Runs bit in the context to build everything.

  Notes:
    - Auto generate name?


how you extend:
1. writing a bash script tool, adding your own mappings around using the tool
2. Extending by compiling in an additional tool which adheres to a standard command line API
3. Python (or other arbitrary binding)?
4. Hand-write a simple json wrapper for the output file (one simple invocation and/or hand written deps)
5. Build a .so conforming to a specific API?

you can always:
1. "freeze" a chain (cut off circular deps, particularly around need the tool to generate dependencies, ...)
   - particularly useful for cutting off first compile time "longest chain"
   - also breaking dependency loops


What can be taken from fastbuild?
How to do simple job scheduling / distribution to tiny cluster?